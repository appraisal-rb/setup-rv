name: "Setup Ruby with rv and ore"
description: "Fast Ruby environment setup using rv for Ruby installation and ore for gem management"
author: "appraisal-rb"

branding:
  icon: "zap"
  color: "red"

inputs:
  ruby-version:
    description: |
      Ruby version to install. Reads from .ruby-version, .tool-versions, or mise.toml if set to 'default'.
      Use 'ruby' for latest stable MRI Ruby version.
      Supported versions: 3.2, 3.3, 3.4, 4.0
    required: false
    default: "default"

  rubygems:
    description: |
      The version of RubyGems to use. Either 'default' (the default), 'latest', or a version number (e.g., 3.3.5).
      For 'default', no action is taken and the version of RubyGems that comes with Ruby by default is used.
      For 'latest', `gem update --system` is run to update to the latest compatible RubyGems version.
      If a version number is given, `gem update --system <version>` is run to update to that version.
    required: false
    default: "default"

  bundler:
    description: |
      The version of Bundler to install. Either 'Gemfile.lock' (the default), 'default', 'latest', 'none', or a version number.
      For 'Gemfile.lock', the version of the BUNDLED WITH section from the Gemfile.lock if it exists.
      For 'default', uses the Bundler version shipped with Ruby if it's 2.2+, otherwise installs 'latest'.
      For 'latest', installs the latest compatible Bundler version (Bundler 2 on Ruby 3.2+).
      For 'none', nothing is done.
    required: false
    default: "Gemfile.lock"

  ore-setup:
    description: |
      Install ore (the gem manager) in the environment.
      Either 'true', 'false', or 'auto' (default).
      When 'auto', ore is installed if ore-install or bundler-cache is true.
      When 'true', ore is always installed even if ore-install is false.
      When 'false', ore is never installed.
      Use 'true' when you want ore available but will run ore commands manually.
    required: false
    default: "auto"

  ore-install:
    description: |
      Run "ore install" command to install gems from lockfile.
      Either 'true' or 'false'.
      Note: Requires ore-setup to be 'true' or 'auto' (with bundler-cache enabled).
      When false, gems are not installed automatically, but ore will still be available if ore-setup is true.
    required: false
    default: "false"

  bundler-cache:
    description: |
      Enable Bundler caching (alias for ore-install for ruby/setup-ruby compatibility).
      When true, acts the same as ore-install: true.
      Either 'true' or 'false'.
      Note: When using fallback to ruby/setup-ruby, this is passed through directly.
    required: false
    default: "false"

  working-directory:
    description: |
      Working directory for resolving version files (.ruby-version, etc.) and Gemfile.
    required: false
    default: "."

  cache-version:
    description: |
      Cache version string. Change this to invalidate caches when needed.
    required: false
    default: "v1"

  rv-version:
    description: |
      Version of rv to install. Either 'latest' or a specific version (e.g., '0.4.0').
      Ignored if rv-git-ref is set.
    required: false
    default: "latest"

  rv-git-ref:
    description: |
      Git branch, tag, or commit SHA to build rv from source.
      When set, rv will be built from the specified git ref instead of using a release.
      Supports fork syntax: Use 'owner:ref' to build from a fork (e.g., 'pboling:feat/my-fix').
      Examples: 'main', 'feat/new-feature', 'v0.5.0-beta', 'pboling:feat/github-token-authenticated-requests'
      Rust toolchain is automatically installed if needed.
    required: false
    default: ""

  ore-version:
    description: |
      Version of ore to install. Either 'latest' or a specific version (e.g., '0.1.0').
      Ignored if ore-git-ref is set.
    required: false
    default: "latest"

  ore-git-ref:
    description: |
      Git branch, tag, or commit SHA to build ore from source.
      When set, ore will be built from the specified git ref instead of using a release.
      Supports fork syntax: Use 'owner:ref' to build from a fork (e.g., 'yourname:feat/my-fix').
      Examples: 'main', 'feat/a-cool-feature', 'v0.19.0-alpha', 'contriboss:feat/bundle-support'
      Go toolchain is automatically installed if needed.
    required: false
    default: ""

  gfgo-git-ref:
    description: |
      Git branch, tag, or commit SHA to build gemfile-go from source when building ore from source.
      Only takes effect when ore-git-ref is also set. Creates a go.work workspace to use local gemfile-go.
      Supports fork syntax: Use 'owner:ref' to build from a fork (e.g., 'yourname:feat/my-fix').
      Examples: 'main', 'feat/new-feature', 'v1.2.3', 'contriboss:feat/enhancement'
    required: false
    default: ""

  skip-extensions:
    description: |
      Skip building native extensions during gem installation.
      Either 'true' or 'false'.
    required: false
    default: "false"

  without-groups:
    description: |
      Gem groups to exclude from installation (comma-separated).
      Example: 'development,test'
    required: false
    default: ""

  ruby-install-retries:
    description: |
      Number of retry attempts for Ruby installation if it fails (e.g., due to GitHub API rate limiting).
      Uses exponential backoff between retries.
    required: false
    default: "3"

  no-document:
    description: |
      Skip generating documentation for installed gems (ri/rdoc).
      Either 'true' or 'false'. Speeds up gem installation significantly.
      Applies to 'gem install' and 'gem update --system' commands.
      Creates .gemrc (if it doesn't exist) to affect Bundler/ore gem installations.
      Preserves existing .gemrc files without modification.
    required: false
    default: "true"

  token:
    description: |
      GitHub token for API calls and downloading releases.
      The default token is usually sufficient.
    required: false
    default: ${{ github.token }}

  use-setup-ruby:
    description: |
      Force fallback to ruby/setup-ruby for specific Ruby versions.
      Use this to benchmark setup-ruby-flash vs setup-ruby for the same version.
      Accepts the same format as ruby-version in a matrix: ['3.4', '4.0'] or just '3.4'
      Takes precedence over automatic detection.
    required: false
    default: ""

  use-setup-ruby-flash:
    description: |
      Force use of setup-ruby-flash for specific Ruby versions.
      Use this for forward compatibility when rv adds support for new versions.
      Accepts the same format as ruby-version in a matrix: ['head', 'jruby'] or just 'head'
      Takes precedence over automatic detection and use-setup-ruby.
      Warning: Will fail if rv doesn't actually support the version.
    required: false
    default: ""

outputs:
  ruby-version:
    description: "The installed Ruby version"
    value: ${{ steps.setup.outputs.ruby-version }}

  ruby-prefix:
    description: "The prefix/path of the installed Ruby"
    value: ${{ steps.setup.outputs.ruby-prefix }}

  rv-version:
    description: "The installed rv version"
    value: ${{ steps.setup.outputs.rv-version }}

  rubygems-version:
    description: "The installed RubyGems version"
    value: ${{ steps.configure-rubygems.outputs.version || steps.setup.outputs.gem-version }}

  bundler-version:
    description: "The installed Bundler version"
    value: ${{ steps.install-bundler.outputs.version || 'default' }}

  ore-version:
    description: "The installed ore version (if ore-install is true)"
    value: ${{ steps.setup.outputs.ore-version }}

  cache-hit:
    description: "Whether gems were restored from cache"
    value: ${{ steps.setup.outputs.cache-hit }}

runs:
  using: "composite"
  steps:
    - name: Check Ruby version support
      id: check-support
      shell: bash
      working-directory: ${{ inputs.working-directory }}
      run: |
        RUBY_VERSION="${{ inputs.ruby-version }}"
        USE_FALLBACK="false"
        OVERRIDE_REASON=""
        
        # Resolve version if 'default'
        if [ "$RUBY_VERSION" = "default" ]; then
          if [ -f ".ruby-version" ]; then
            RUBY_VERSION=$(cat .ruby-version | head -1 | sed 's/^ruby-//' | tr -d '[:space:]')
          elif [ -f ".tool-versions" ]; then
            RUBY_VERSION=$(grep '^ruby ' .tool-versions | awk '{print $2}' | sed 's/^ruby-//')
          elif [ -f "mise.toml" ]; then
            RUBY_VERSION=$(grep 'ruby' mise.toml | sed 's/.*= *"\?\([^"]*\)"\?.*/\1/' | sed 's/^ruby-//')
          fi
        elif [ "$RUBY_VERSION" = "ruby" ]; then
          RUBY_VERSION="4.0"
        fi
        
        # Parse use-setup-ruby-flash override (highest priority)
        USE_FLASH_LIST='${{ inputs.use-setup-ruby-flash }}'
        if [ -n "$USE_FLASH_LIST" ]; then
          # Handle single value (e.g., "3.4") or array (e.g., ['3.4', '4.0'])
          # Check if current version matches (with quotes or without)
          if [ "$USE_FLASH_LIST" = "$RUBY_VERSION" ] || \
             echo "$USE_FLASH_LIST" | grep -qE "(^|[^a-z0-9.])$RUBY_VERSION([^a-z0-9.]|$)"; then
            echo "::notice::Ruby version '$RUBY_VERSION' forced to use setup-ruby-flash via use-setup-ruby-flash input."
            USE_FALLBACK="false"
            OVERRIDE_REASON="forced-flash"
          fi
        fi
        
        # Parse use-setup-ruby override (second priority, only if not forced to flash)
        if [ "$OVERRIDE_REASON" != "forced-flash" ]; then
          USE_RUBY_LIST='${{ inputs.use-setup-ruby }}'
          if [ -n "$USE_RUBY_LIST" ]; then
            # Handle single value or array format
            if [ "$USE_RUBY_LIST" = "$RUBY_VERSION" ] || \
               echo "$USE_RUBY_LIST" | grep -qE "(^|[^a-z0-9.])$RUBY_VERSION([^a-z0-9.]|$)"; then
              echo "::notice::Ruby version '$RUBY_VERSION' forced to use ruby/setup-ruby via use-setup-ruby input."
              USE_FALLBACK="true"
              OVERRIDE_REASON="forced-ruby"
            fi
          fi
        fi
        
        # Automatic detection (only if no override)
        if [ -z "$OVERRIDE_REASON" ]; then
          # Allowlists of supported Ruby versions (update these as rv adds support)
          # Numeric MRI versions (major.minor format)
          SUPPORTED_NUMERIC_VERSIONS="3.2 3.3 3.4 4.0"
          # Special versions and alternative implementations (e.g., head, jruby, truffleruby)
          SUPPORTED_SPECIAL_VERSIONS=""  # Empty for now, add versions as rv supports them (e.g., "head jruby truffleruby")
        
          # Default to fallback unless version is in allowlist
          USE_FALLBACK="true"
        
          # First check if it's a prefix match in special versions (head, jruby-*, truffleruby-*, etc.)
          if [ -n "$SUPPORTED_SPECIAL_VERSIONS" ]; then
            for allowed_version in $SUPPORTED_SPECIAL_VERSIONS; do
              if [[ "$RUBY_VERSION" == $allowed_version* ]]; then
                echo "Ruby version '$RUBY_VERSION' is supported by setup-ruby-flash."
                USE_FALLBACK="false"
                break
              fi
            done
          fi
        
          # If not found in special versions, check numeric versions
          if [ "$USE_FALLBACK" = "true" ]; then
            # Extract major.minor version (e.g., "3.4.1" -> "3.4")
            # Use || true to prevent exit on no match
            VERSION_PREFIX=$(echo "$RUBY_VERSION" | grep -oE '^[0-9]+\.[0-9]+' || true)
        
            if [ -n "$VERSION_PREFIX" ]; then
              for allowed_version in $SUPPORTED_NUMERIC_VERSIONS; do
                if [ "$VERSION_PREFIX" = "$allowed_version" ]; then
                  echo "Ruby version '$RUBY_VERSION' is supported by setup-ruby-flash."
                  USE_FALLBACK="false"
                  break
                fi
              done
            fi
          fi
        
          # If still using fallback, show appropriate message
          if [ "$USE_FALLBACK" = "true" ]; then
            ALL_SUPPORTED="$SUPPORTED_NUMERIC_VERSIONS"
            if [ -n "$SUPPORTED_SPECIAL_VERSIONS" ]; then
              ALL_SUPPORTED="$ALL_SUPPORTED $SUPPORTED_SPECIAL_VERSIONS"
            fi
            echo "::notice::Ruby version '$RUBY_VERSION' is not supported by setup-ruby-flash (only$ALL_SUPPORTED supported). Falling back to ruby/setup-ruby."
          fi
        fi
        
        echo "use-fallback=$USE_FALLBACK" >> $GITHUB_OUTPUT
        echo "ruby-version=$RUBY_VERSION" >> $GITHUB_OUTPUT

    - name: Start fallback timer
      if: steps.check-support.outputs.use-fallback == 'true'
      id: fallback-start
      shell: bash
      run: |
        echo "start-time=$(date +%s)" >> $GITHUB_OUTPUT

    - name: Setup Ruby with ruby/setup-ruby (fallback)
      if: steps.check-support.outputs.use-fallback == 'true'
      uses: ruby/setup-ruby@v1
      with:
        ruby-version: ${{ inputs.ruby-version }}
        rubygems: ${{ inputs.rubygems }}
        bundler: ${{ inputs.bundler }}
        bundler-cache: ${{ inputs.bundler-cache == 'true' || inputs.ore-install == 'true' }}
        working-directory: ${{ inputs.working-directory }}
        cache-version: ${{ inputs.cache-version }}

    - name: End fallback timer
      if: steps.check-support.outputs.use-fallback == 'true'
      id: fallback-end
      shell: bash
      run: |
        END_TIME=$(date +%s)
        START_TIME=${{ steps.fallback-start.outputs.start-time }}
        ELAPSED=$((END_TIME - START_TIME))
        echo "elapsed=$ELAPSED" >> $GITHUB_OUTPUT
        echo "setup-ruby fallback completed in ${ELAPSED}s"

    - name: Validate platform
      if: steps.check-support.outputs.use-fallback != 'true'
      id: platform
      shell: bash
      run: |
        # Detect OS
        case "$RUNNER_OS" in
          Linux)   OS="linux" ;;
          macOS)   OS="darwin" ;;
          *)
            echo "::error::Unsupported OS: $RUNNER_OS. setup-ruby-flash only supports Linux and macOS."
            exit 1
            ;;
        esac

        # Detect architecture
        ARCH="$(uname -m)"
        case "$ARCH" in
          x86_64)  ARCH="amd64" ;;
          aarch64) ARCH="arm64" ;;
          arm64)   ARCH="arm64" ;;
          *)
            echo "::error::Unsupported architecture: $ARCH. setup-ruby-flash only supports x86_64 and arm64."
            exit 1
            ;;
        esac

        echo "os=$OS" >> $GITHUB_OUTPUT
        echo "arch=$ARCH" >> $GITHUB_OUTPUT
        echo "platform=$OS-$ARCH" >> $GITHUB_OUTPUT
        echo "Detected platform: $OS-$ARCH"

    - name: Resolve rv version
      if: steps.check-support.outputs.use-fallback != 'true'
      id: rv-version
      shell: bash
      env:
        GH_TOKEN: ${{ inputs.token }}
      run: |
        # If git ref is specified, resolve to commit SHA for cache key
        if [ -n "${{ inputs.rv-git-ref }}" ]; then
          GIT_REF="${{ inputs.rv-git-ref }}"
          echo "build-from-source=true" >> $GITHUB_OUTPUT
        
          # Parse fork syntax: owner:ref or just ref
          if [[ "$GIT_REF" == *":"* ]]; then
            FORK_OWNER="${GIT_REF%%:*}"
            REF="${GIT_REF#*:}"
            REPO="$FORK_OWNER/rv"
          else
            REPO="spinel-coop/rv"
            REF="$GIT_REF"
          fi
        
          # Resolve to commit SHA using GitHub API
          COMMIT_SHA=$(gh api "repos/$REPO/commits/$REF" --jq '.sha' 2>/dev/null || echo "$REF")
          VERSION="${COMMIT_SHA:0:12}"  # Use first 12 chars of SHA
          echo "Using rv git ref: $GIT_REF (commit: $VERSION)"
        elif [ "${{ inputs.rv-version }}" = "latest" ]; then
          VERSION=$(gh api repos/spinel-coop/rv/releases/latest --jq '.tag_name' 2>/dev/null || echo "v0.4.1")
          echo "build-from-source=false" >> $GITHUB_OUTPUT
        else
          VERSION="${{ inputs.rv-version }}"
          echo "build-from-source=false" >> $GITHUB_OUTPUT
        fi
        VERSION="${VERSION#v}"
        echo "version=$VERSION" >> $GITHUB_OUTPUT
        echo "Resolved rv version: $VERSION"

    - name: Cache rv binary
      if: steps.check-support.outputs.use-fallback != 'true'
      id: cache-rv
      uses: actions/cache@v4
      with:
        path: ~/.local/bin/rv
        key: setup-ruby-flash-rv-${{ steps.platform.outputs.platform }}-${{ steps.rv-version.outputs.version }}-${{ steps.rv-version.outputs.build-from-source }}

    - name: Setup Rust toolchain for rv
      if: steps.check-support.outputs.use-fallback != 'true' && steps.cache-rv.outputs.cache-hit != 'true' && steps.rv-version.outputs.build-from-source == 'true'
      uses: dtolnay/rust-toolchain@stable

    - name: Build rv from source
      if: steps.check-support.outputs.use-fallback != 'true' && steps.cache-rv.outputs.cache-hit != 'true' && steps.rv-version.outputs.build-from-source == 'true'
      id: build-rv
      shell: bash
      run: |
        GIT_REF="${{ inputs.rv-git-ref }}"
        echo "Building rv from source (git ref: $GIT_REF)..."
        START_TIME=$(date +%s)

        # Parse fork syntax: owner:ref or just ref
        if [[ "$GIT_REF" == *":"* ]]; then
          FORK_OWNER="${GIT_REF%%:*}"
          REF="${GIT_REF#*:}"
          REPO_URL="https://github.com/${FORK_OWNER}/rv.git"
          echo "Using fork: $FORK_OWNER/rv (ref: $REF)"
        else
          REPO_URL="https://github.com/spinel-coop/rv.git"
          REF="$GIT_REF"
          echo "Using upstream: spinel-coop/rv (ref: $REF)"
        fi

        # Clone repository (shallow clone for speed)
        git clone --depth 1 "$REPO_URL" /tmp/rv-build
        cd /tmp/rv-build
        # Fetch the specific ref if shallow clone doesn't have it
        if ! git checkout "$REF" 2>/dev/null; then
          git fetch --depth 1 origin "$REF"
          if ! git checkout FETCH_HEAD; then
            echo "::error::Failed to checkout rv git ref: $REF from $REPO_URL"
            exit 1
          fi
        fi


        # Build rv using cargo
        cargo build --release

        # Install to ~/.local/bin
        mkdir -p ~/.local/bin
        cp target/release/rv ~/.local/bin/rv
        chmod +x ~/.local/bin/rv

        END_TIME=$(date +%s)
        ELAPSED=$((END_TIME - START_TIME))
        echo "build-time=$ELAPSED" >> $GITHUB_OUTPUT
        echo "Built and installed rv from $GIT_REF in ${ELAPSED}s"
        ~/.local/bin/rv --version

        # Cleanup build directory
        rm -rf /tmp/rv-build

    - name: Install rv from release
      if: steps.check-support.outputs.use-fallback != 'true' && steps.cache-rv.outputs.cache-hit != 'true' && steps.rv-version.outputs.build-from-source == 'false'
      id: install-rv
      shell: bash
      run: |
        VERSION="${{ steps.rv-version.outputs.version }}"
        OS="${{ steps.platform.outputs.os }}"
        ARCH="${{ steps.platform.outputs.arch }}"
        START_TIME=$(date +%s)

        # Map to rv platform names
        case "$OS-$ARCH" in
          linux-amd64)  RV_PLATFORM="x86_64-unknown-linux-gnu" ;;
          linux-arm64)  RV_PLATFORM="aarch64-unknown-linux-gnu" ;;
          darwin-amd64) RV_PLATFORM="x86_64-apple-darwin" ;;
          darwin-arm64) RV_PLATFORM="aarch64-apple-darwin" ;;
        esac

        # rv releases use .tar.xz format with files in a subdirectory
        DOWNLOAD_URL="https://github.com/spinel-coop/rv/releases/download/v${VERSION}/rv-${RV_PLATFORM}.tar.xz"
        echo "Downloading rv from: $DOWNLOAD_URL"

        mkdir -p ~/.local/bin
        curl -fsSL "$DOWNLOAD_URL" | tar -xJ --strip-components=1 -C ~/.local/bin "rv-${RV_PLATFORM}/rv"
        chmod +x ~/.local/bin/rv

        END_TIME=$(date +%s)
        ELAPSED=$((END_TIME - START_TIME))
        echo "install-time=$ELAPSED" >> $GITHUB_OUTPUT
        echo "Installed rv $VERSION in ${ELAPSED}s"

    - name: Add rv to PATH
      if: steps.check-support.outputs.use-fallback != 'true'
      shell: bash
      run: |
        echo "$HOME/.local/bin" >> $GITHUB_PATH

    - name: Detect Ruby version
      if: steps.check-support.outputs.use-fallback != 'true'
      id: detect-ruby
      shell: bash
      working-directory: ${{ inputs.working-directory }}
      run: |
        RUBY_VERSION="${{ inputs.ruby-version }}"

        # 'ruby' means latest stable Ruby version (like setup-ruby)
        if [ "$RUBY_VERSION" = "ruby" ]; then
          RUBY_VERSION="4.0"
          echo "Using latest stable Ruby version: $RUBY_VERSION"
        elif [ "$RUBY_VERSION" = "default" ]; then
          # Check version files in order of precedence
          if [ -f ".ruby-version" ]; then
            RUBY_VERSION=$(cat .ruby-version | head -1 | sed 's/^ruby-//' | tr -d '[:space:]')
            echo "Found Ruby version in .ruby-version: $RUBY_VERSION"
          elif [ -f ".tool-versions" ]; then
            RUBY_VERSION=$(grep '^ruby ' .tool-versions | awk '{print $2}' | sed 's/^ruby-//')
            echo "Found Ruby version in .tool-versions: $RUBY_VERSION"
          elif [ -f "mise.toml" ]; then
            RUBY_VERSION=$(grep 'ruby' mise.toml | sed 's/.*= *"\?\([^"]*\)"\?.*/\1/' | sed 's/^ruby-//')
            echo "Found Ruby version in mise.toml: $RUBY_VERSION"
          else
            echo "::error::No Ruby version specified and no version file found (.ruby-version, .tool-versions, mise.toml)"
            exit 1
          fi
        fi

        echo "version=$RUBY_VERSION" >> $GITHUB_OUTPUT
        echo "Using Ruby version: $RUBY_VERSION"

    - name: Cache Ruby installation
      if: steps.check-support.outputs.use-fallback != 'true'
      id: cache-ruby
      uses: actions/cache@v4
      with:
        path: ~/.local/share/rv/rubies
        key: setup-ruby-flash-ruby-${{ inputs.cache-version }}-${{ steps.platform.outputs.platform }}-${{ steps.detect-ruby.outputs.version }}

    - name: Install Ruby
      if: steps.check-support.outputs.use-fallback != 'true' && steps.cache-ruby.outputs.cache-hit != 'true'
      id: install-ruby
      shell: bash
      env:
        GITHUB_TOKEN: ${{ inputs.token }}
      run: |
        RUBY_VERSION="${{ steps.detect-ruby.outputs.version }}"
        MAX_RETRIES=${{ inputs.ruby-install-retries }}
        RETRY_COUNT=0
        BACKOFF=5
        START_TIME=$(date +%s)

        # Pre-seed rv's releases cache with authenticated API call to avoid rate limiting
        # ...existing code...

        echo "Installing Ruby $RUBY_VERSION via rv (max retries: $MAX_RETRIES)..."

        while [ $RETRY_COUNT -lt $MAX_RETRIES ]; do
          RETRY_COUNT=$((RETRY_COUNT + 1))
          echo "Attempt $RETRY_COUNT of $MAX_RETRIES..."
        
          if ~/.local/bin/rv ruby install "$RUBY_VERSION"; then
            END_TIME=$(date +%s)
            ELAPSED=$((END_TIME - START_TIME))
            echo "install-time=$ELAPSED" >> $GITHUB_OUTPUT
            echo "Ruby $RUBY_VERSION installed successfully on attempt $RETRY_COUNT in ${ELAPSED}s"
            exit 0
          fi

          if [ $RETRY_COUNT -lt $MAX_RETRIES ]; then
            echo "::warning::rv ruby install failed (attempt $RETRY_COUNT/$MAX_RETRIES). Retrying in ${BACKOFF}s..."
            sleep $BACKOFF
            BACKOFF=$((BACKOFF * 2))
          fi
        done

        echo "::error::Failed to install Ruby $RUBY_VERSION after $MAX_RETRIES attempts"
        exit 1

    - name: Configure Ruby environment with rv shell integration
      if: steps.check-support.outputs.use-fallback != 'true'
      id: setup
      shell: bash
      working-directory: ${{ inputs.working-directory }}
      run: |
        RUBY_VERSION="${{ steps.detect-ruby.outputs.version }}"

        # Always overwrite .ruby-version to ensure it matches the installed Ruby version
        # In CI, we expect to use the specified Ruby version regardless of local .ruby-version
        echo "$RUBY_VERSION" > .ruby-version
        echo "Created .ruby-version with $RUBY_VERSION"

        # Activate rv shell integration to set up PATH and environment
        # This will now use the .ruby-version file we just created
        eval "$(~/.local/bin/rv shell env bash)"

        # Verify Ruby is now active
        RUBY_EXECUTABLE=$(which ruby)
        if [ -z "$RUBY_EXECUTABLE" ]; then
          echo "::error::Ruby not found in PATH after rv activation"
          ~/.local/bin/rv ruby list || true
          exit 1
        fi

        # Get Ruby installation details
        RUBY_BIN_DIR=$(dirname "$RUBY_EXECUTABLE")
        RUBY_PREFIX=$(dirname "$RUBY_BIN_DIR")
        echo "Found Ruby at: $RUBY_PREFIX"
        
        # Determine GEM_HOME based on rv's Ruby installation structure
        # rv installs gems to: $RUBY_PREFIX/lib/ruby/gems/$MAJOR.$MINOR.0
        FULL_RUBY_VERSION=$(ruby -e 'print RUBY_VERSION')
        MAJOR_MINOR=$(echo "$FULL_RUBY_VERSION" | cut -d. -f1,2)
        ACTUAL_GEM_HOME="$RUBY_PREFIX/lib/ruby/gems/${MAJOR_MINOR}.0"
        ACTUAL_GEM_PATH="$ACTUAL_GEM_HOME"
        
        echo "Setting GEM_HOME to: $ACTUAL_GEM_HOME"
        
        # Export environment variables to GITHUB_ENV for subsequent steps
        echo "GEM_HOME=$ACTUAL_GEM_HOME" >> $GITHUB_ENV
        echo "GEM_PATH=$ACTUAL_GEM_PATH" >> $GITHUB_ENV
        
        # Export other Ruby-related variables if they're set
        [ -n "$RUBY_ROOT" ] && echo "RUBY_ROOT=$RUBY_ROOT" >> $GITHUB_ENV
        [ -n "$RUBY_ENGINE" ] && echo "RUBY_ENGINE=$RUBY_ENGINE" >> $GITHUB_ENV
        [ -n "$RUBY_VERSION" ] && echo "RUBY_VERSION=$RUBY_VERSION" >> $GITHUB_ENV
        [ -n "$RUBYOPT" ] && echo "RUBYOPT=$RUBYOPT" >> $GITHUB_ENV

        # Add Ruby to GITHUB_PATH for subsequent steps
        echo "$RUBY_BIN_DIR" >> $GITHUB_PATH

        # Get versions for outputs
        GEM_VERSION=$(gem --version)

        # Set outputs
        echo "ruby-version=$RUBY_VERSION" >> $GITHUB_OUTPUT
        echo "ruby-full-version=$FULL_RUBY_VERSION" >> $GITHUB_OUTPUT
        echo "ruby-prefix=$RUBY_PREFIX" >> $GITHUB_OUTPUT
        echo "rv-version=${{ steps.rv-version.outputs.version }}" >> $GITHUB_OUTPUT
        echo "gem-version=$GEM_VERSION" >> $GITHUB_OUTPUT

        # Verify Ruby installation
        ruby --version
        gem --version

    - name: Configure RubyGems
      if: steps.check-support.outputs.use-fallback != 'true' && inputs.rubygems != 'default'
      id: configure-rubygems
      shell: bash
      run: |
        RUBYGEMS_INPUT="${{ inputs.rubygems }}"
        CURRENT_VERSION=$(gem --version)
        echo "Current RubyGems version: $CURRENT_VERSION"

        # Set silent flag when no-document is enabled
        SILENT_FLAG=""
        if [ "${{ inputs.no-document }}" = "true" ]; then
          SILENT_FLAG="--silent"
        fi

        if [ "$RUBYGEMS_INPUT" = "latest" ]; then
          echo "Updating RubyGems to latest version..."
          gem update --system $SILENT_FLAG
          NEW_VERSION=$(gem --version)
          echo "Updated RubyGems to: $NEW_VERSION"
          echo "version=$NEW_VERSION" >> $GITHUB_OUTPUT
        elif [ -n "$RUBYGEMS_INPUT" ]; then
          # Check if requested version is newer than current
          if ruby -e "exit(Gem::Version.new('$RUBYGEMS_INPUT') > Gem::Version.new('$CURRENT_VERSION') ? 0 : 1)" 2>/dev/null; then
            echo "Updating RubyGems to version $RUBYGEMS_INPUT..."
            gem update --system "$RUBYGEMS_INPUT" $SILENT_FLAG
            echo "version=$RUBYGEMS_INPUT" >> $GITHUB_OUTPUT
          else
            echo "Requested RubyGems version ($RUBYGEMS_INPUT) is not newer than current ($CURRENT_VERSION), skipping update"
            echo "version=$CURRENT_VERSION" >> $GITHUB_OUTPUT
          fi
        fi

    - name: Install Bundler
      if: steps.check-support.outputs.use-fallback != 'true' && inputs.bundler != 'none'
      id: install-bundler
      shell: bash
      working-directory: ${{ inputs.working-directory }}
      run: |
        BUNDLER_INPUT="${{ inputs.bundler }}"
        RUBY_VERSION="${{ steps.setup.outputs.ruby-full-version }}"

        # Set documentation flag based on input
        DOC_FLAG=""
        if [ "${{ inputs.no-document }}" = "true" ]; then
          DOC_FLAG="--no-document"
        fi

        # Helper function to check if a specific bundler version is installed
        is_bundler_installed() {
          local version="$1"
          gem list bundler --installed --version "$version" >/dev/null 2>&1
        }

        # Helper function to check if bundler satisfies a version requirement
        bundler_satisfies() {
          local required="$1"
          local current="$2"
          # If we just need major version match (e.g., "2" or "4"), check major only
          if [[ "$required" =~ ^[0-9]+$ ]]; then
            local required_major="${required}"
            local current_major="${current%%.*}"
            [ "$required_major" = "$current_major" ]
          else
            # For specific version, check exact match or compatible
            [ "$required" = "$current" ]
          fi
        }

        # Get currently installed bundler version
        CURRENT_BUNDLER=$(bundle --version 2>/dev/null | awk '{print $NF}' || echo "")
        if [ -n "$CURRENT_BUNDLER" ]; then
          echo "Current Bundler version: $CURRENT_BUNDLER"
        fi

        # Determine Bundler version to install
        if [ "$BUNDLER_INPUT" = "Gemfile.lock" ]; then
          if [ -f "Gemfile.lock" ]; then
            # Extract BUNDLED WITH version from Gemfile.lock
            BUNDLER_VERSION=$(awk '/^BUNDLED WITH$/{getline; print $1}' Gemfile.lock 2>/dev/null || echo "")
            if [ -n "$BUNDLER_VERSION" ]; then
              echo "Found Bundler version in Gemfile.lock: $BUNDLER_VERSION"
              # Check if this version is already installed
              if is_bundler_installed "$BUNDLER_VERSION"; then
                echo "Bundler $BUNDLER_VERSION is already installed"
                echo "version=$BUNDLER_VERSION" >> $GITHUB_OUTPUT
                exit 0
              fi
            else
              echo "No BUNDLED WITH found in Gemfile.lock, using default"
              BUNDLER_INPUT="default"
            fi
          else
            echo "No Gemfile.lock found, using default Bundler"
            BUNDLER_INPUT="default"
          fi
        fi

        if [ "$BUNDLER_INPUT" = "default" ]; then
          # Ruby 3.2+ ships with Bundler 2.2+, use it
          if [ -n "$CURRENT_BUNDLER" ]; then
            echo "Using default Bundler: $CURRENT_BUNDLER"
            echo "version=$CURRENT_BUNDLER" >> $GITHUB_OUTPUT
            exit 0
          fi
          BUNDLER_INPUT="latest"
        fi

        if [ "$BUNDLER_INPUT" = "latest" ]; then
          # If RubyGems was updated to latest, it already installed the latest Bundler
          # (RubyGems and Bundler are always released together)
          if [ "${{ inputs.rubygems }}" = "latest" ] && [ -n "${{ steps.configure-rubygems.outputs.version }}" ]; then
            CURRENT_BUNDLER=$(bundle --version 2>/dev/null | awk '{print $NF}' || echo "")
            if [ -n "$CURRENT_BUNDLER" ]; then
              echo "Using Bundler $CURRENT_BUNDLER (installed with latest RubyGems)"
              echo "version=$CURRENT_BUNDLER" >> $GITHUB_OUTPUT
              exit 0
            fi
          fi

          # Check if we already have a recent bundler
          if [ -n "$CURRENT_BUNDLER" ]; then
            CURRENT_MAJOR="${CURRENT_BUNDLER%%.*}"
            # If we have Bundler 2+, that's fine for "latest" on most Rubies
            if [ "$CURRENT_MAJOR" -ge 2 ]; then
              echo "Using existing Bundler $CURRENT_BUNDLER (satisfies 'latest')"
              echo "version=$CURRENT_BUNDLER" >> $GITHUB_OUTPUT
              exit 0
            fi
          fi
          echo "Installing latest Bundler..."
          gem install bundler $DOC_FLAG --force 2>/dev/null || gem install bundler $DOC_FLAG
          INSTALLED_VERSION=$(bundle --version | awk '{print $NF}')
          echo "Installed Bundler: $INSTALLED_VERSION"
          echo "version=$INSTALLED_VERSION" >> $GITHUB_OUTPUT
        elif [ -n "$BUNDLER_VERSION" ]; then
          # Install specific version from Gemfile.lock
          echo "Installing Bundler version $BUNDLER_VERSION..."
          gem install bundler -v "$BUNDLER_VERSION" $DOC_FLAG --force 2>/dev/null || \
            gem install bundler -v "$BUNDLER_VERSION" $DOC_FLAG
          echo "version=$BUNDLER_VERSION" >> $GITHUB_OUTPUT
        elif [[ "$BUNDLER_INPUT" =~ ^[0-9] ]]; then
          # Version number provided - check if already satisfied
          if [ -n "$CURRENT_BUNDLER" ] && bundler_satisfies "$BUNDLER_INPUT" "$CURRENT_BUNDLER"; then
            echo "Using existing Bundler $CURRENT_BUNDLER (satisfies '$BUNDLER_INPUT')"
            echo "version=$CURRENT_BUNDLER" >> $GITHUB_OUTPUT
            exit 0
          fi
          echo "Installing Bundler version $BUNDLER_INPUT..."
          if [[ "$BUNDLER_INPUT" =~ ^[0-9]+$ ]]; then
            # Just major version, use ~> constraint
            gem install bundler -v "~> $BUNDLER_INPUT.0" $DOC_FLAG --force 2>/dev/null || \
              gem install bundler -v "~> $BUNDLER_INPUT.0" $DOC_FLAG
          else
            gem install bundler -v "$BUNDLER_INPUT" $DOC_FLAG --force 2>/dev/null || \
              gem install bundler -v "$BUNDLER_INPUT" $DOC_FLAG
          fi
          INSTALLED_VERSION=$(bundle --version | awk '{print $NF}')
          echo "version=$INSTALLED_VERSION" >> $GITHUB_OUTPUT
        fi

    - name: Generate summary (Ruby only)
      if: steps.check-support.outputs.use-fallback != 'true' && steps.should-install-ore.outputs.install-ore != 'true'
      shell: bash
      run: |
        RUBYGEMS_VERSION="${{ steps.configure-rubygems.outputs.version }}"
        if [ -z "$RUBYGEMS_VERSION" ]; then
          RUBYGEMS_VERSION="${{ steps.setup.outputs.gem-version }}"
        fi
        BUNDLER_VERSION="${{ steps.install-bundler.outputs.version }}"
        if [ -z "$BUNDLER_VERSION" ]; then
          BUNDLER_VERSION=$(bundle --version 2>/dev/null | awk '{print $NF}' || echo "default")
        fi

        echo "### setup-ruby-flash Summary âš¡" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "| Component | Value |" >> $GITHUB_STEP_SUMMARY
        echo "|-----------|-------|" >> $GITHUB_STEP_SUMMARY
        echo "| Ruby Version | ${{ steps.detect-ruby.outputs.version }} |" >> $GITHUB_STEP_SUMMARY
        echo "| RubyGems Version | $RUBYGEMS_VERSION |" >> $GITHUB_STEP_SUMMARY
        echo "| Bundler Version | $BUNDLER_VERSION |" >> $GITHUB_STEP_SUMMARY
        echo "| rv Version | ${{ steps.rv-version.outputs.version }} |" >> $GITHUB_STEP_SUMMARY
        echo "| Platform | ${{ steps.platform.outputs.platform }} |" >> $GITHUB_STEP_SUMMARY
        echo "| Ruby Cache Hit | ${{ steps.cache-ruby.outputs.cache-hit }} |" >> $GITHUB_STEP_SUMMARY
        
        # Add timing information if available
        if [ -n "${{ steps.build-rv.outputs.build-time }}" ]; then
          echo "| rv Build Time | ${{ steps.build-rv.outputs.build-time }}s |" >> $GITHUB_STEP_SUMMARY
        fi
        if [ -n "${{ steps.install-rv.outputs.install-time }}" ]; then
          echo "| rv Install Time | ${{ steps.install-rv.outputs.install-time }}s |" >> $GITHUB_STEP_SUMMARY
        fi
        if [ -n "${{ steps.install-ruby.outputs.install-time }}" ]; then
          echo "| Ruby Install Time | ${{ steps.install-ruby.outputs.install-time }}s |" >> $GITHUB_STEP_SUMMARY
        fi

    - name: Determine if ore should be installed
      if: steps.check-support.outputs.use-fallback != 'true'
      id: should-install-ore
      shell: bash
      run: |
        ORE_SETUP="${{ inputs.ore-setup }}"
        ORE_INSTALL="${{ inputs.ore-install }}"
        BUNDLER_CACHE="${{ inputs.bundler-cache }}"
        
        # Determine if ore should be installed
        if [ "$ORE_SETUP" = "true" ]; then
          echo "install-ore=true" >> $GITHUB_OUTPUT
          echo "Ore will be installed (ore-setup: true)"
        elif [ "$ORE_SETUP" = "false" ]; then
          echo "install-ore=false" >> $GITHUB_OUTPUT
          echo "Ore will NOT be installed (ore-setup: false)"
        else
          # auto mode: install if ore-install or bundler-cache is true
          if [ "$ORE_INSTALL" = "true" ] || [ "$BUNDLER_CACHE" = "true" ]; then
            echo "install-ore=true" >> $GITHUB_OUTPUT
            echo "Ore will be installed (ore-setup: auto, ore-install or bundler-cache enabled)"
          else
            echo "install-ore=false" >> $GITHUB_OUTPUT
            echo "Ore will NOT be installed (ore-setup: auto, no gem installation requested)"
          fi
        fi

    - name: Resolve ore version
      if: steps.check-support.outputs.use-fallback != 'true' && steps.should-install-ore.outputs.install-ore == 'true'
      id: ore-version
      shell: bash
      env:
        GH_TOKEN: ${{ inputs.token }}
      run: |
        # If git ref is specified, resolve to commit SHA for cache key
        if [ -n "${{ inputs.ore-git-ref }}" ]; then
          GIT_REF="${{ inputs.ore-git-ref }}"
          echo "build-from-source=true" >> $GITHUB_OUTPUT
        
          # Parse fork syntax: owner:ref or just ref
          if [[ "$GIT_REF" == *":"* ]]; then
            FORK_OWNER="${GIT_REF%%:*}"
            REF="${GIT_REF#*:}"
            REPO="$FORK_OWNER/ore-light"
          else
            REPO="contriboss/ore-light"
            REF="$GIT_REF"
          fi
        
          # Resolve to commit SHA using GitHub API
          COMMIT_SHA=$(gh api "repos/$REPO/commits/$REF" --jq '.sha' 2>/dev/null || echo "$REF")
          VERSION="${COMMIT_SHA:0:12}"  # Use first 12 chars of SHA
          echo "Using ore git ref: $GIT_REF (commit: $VERSION)"
        elif [ "${{ inputs.ore-version }}" = "latest" ]; then
          VERSION=$(gh api repos/contriboss/ore-light/releases/latest --jq '.tag_name' 2>/dev/null || echo "v0.18.0")
          echo "build-from-source=false" >> $GITHUB_OUTPUT
        else
          VERSION="${{ inputs.ore-version }}"
          echo "build-from-source=false" >> $GITHUB_OUTPUT
        fi
        VERSION="${VERSION#v}"
        echo "version=$VERSION" >> $GITHUB_OUTPUT
        echo "Resolved ore version: $VERSION"
        
        # Also resolve gfgo-git-ref if specified (affects ore cache key)
        if [ -n "${{ inputs.gfgo-git-ref }}" ]; then
          GFGO_REF="${{ inputs.gfgo-git-ref }}"
        
          # Parse fork syntax: owner:ref or just ref
          if [[ "$GFGO_REF" == *":"* ]]; then
            GFGO_FORK_OWNER="${GFGO_REF%%:*}"
            GFGO_REF_NAME="${GFGO_REF#*:}"
            GFGO_REPO="$GFGO_FORK_OWNER/gemfile-go"
          else
            GFGO_REPO="contriboss/gemfile-go"
            GFGO_REF_NAME="$GFGO_REF"
          fi
        
          # Resolve to commit SHA
          GFGO_SHA=$(gh api "repos/$GFGO_REPO/commits/$GFGO_REF_NAME" --jq '.sha' 2>/dev/null || echo "$GFGO_REF")
          GFGO_VERSION="${GFGO_SHA:0:12}"
          echo "gfgo-version=$GFGO_VERSION" >> $GITHUB_OUTPUT
          echo "Using gemfile-go git ref: $GFGO_REF (commit: $GFGO_VERSION)"
        else
          echo "gfgo-version=" >> $GITHUB_OUTPUT
        fi

    - name: Cache ore binary
      if: steps.check-support.outputs.use-fallback != 'true' && steps.should-install-ore.outputs.install-ore == 'true'
      id: cache-ore
      uses: actions/cache@v4
      with:
        path: ~/.local/bin/ore
        key: setup-ruby-flash-ore-${{ steps.platform.outputs.platform }}-ruby-${{ steps.detect-ruby.outputs.version }}-${{ steps.ore-version.outputs.version }}-${{ steps.ore-version.outputs.build-from-source }}-gfgo-${{ steps.ore-version.outputs.gfgo-version }}

    - name: Setup Go toolchain for ore
      if: steps.check-support.outputs.use-fallback != 'true' && steps.should-install-ore.outputs.install-ore == 'true' && steps.cache-ore.outputs.cache-hit != 'true' && steps.ore-version.outputs.build-from-source == 'true'
      uses: actions/setup-go@v5
      with:
        go-version: "stable"

    - name: Build ore from source
      if: steps.check-support.outputs.use-fallback != 'true' && steps.should-install-ore.outputs.install-ore == 'true' && steps.cache-ore.outputs.cache-hit != 'true' && steps.ore-version.outputs.build-from-source == 'true'
      id: build-ore
      shell: bash
      run: |
        # Get the Ruby version we should be using
        RUBY_VERSION="${{ steps.detect-ruby.outputs.version }}"
        
        # Activate rv shell integration with the specific Ruby version
        # Save the current .ruby-version if it exists
        if [ -f .ruby-version ]; then
          SAVED_RUBY_VERSION=$(cat .ruby-version)
          HAD_RUBY_VERSION=true
        else
          HAD_RUBY_VERSION=false
        fi
        
        # Create/overwrite .ruby-version with the Ruby version we're using
        echo "$RUBY_VERSION" > .ruby-version
        
        # Use rv shell integration to set up the environment
        eval "$(~/.local/bin/rv shell env bash)"
        
        # Restore original .ruby-version or remove it
        if [ "$HAD_RUBY_VERSION" = true ]; then
          echo "$SAVED_RUBY_VERSION" > .ruby-version
        else
          rm -f .ruby-version
        fi
        
        # Verify Ruby is active
        echo "Ruby in PATH: $(which ruby)"
        echo "Ruby version: $(ruby --version)"
        
        GIT_REF="${{ inputs.ore-git-ref }}"
        GFGO_GIT_REF="${{ inputs.gfgo-git-ref }}"
        echo "Building ore from source (git ref: $GIT_REF)..."
        ORE_START_TIME=$(date +%s)

        # Parse fork syntax: owner:ref or just ref
        if [[ "$GIT_REF" == *":"* ]]; then
          FORK_OWNER="${GIT_REF%%:*}"
          REF="${GIT_REF#*:}"
          REPO_URL="https://github.com/${FORK_OWNER}/ore-light.git"
          echo "Using fork: $FORK_OWNER/ore-light (ref: $REF)"
        else
          REPO_URL="https://github.com/contriboss/ore-light.git"
          REF="$GIT_REF"
          echo "Using upstream: contriboss/ore-light (ref: $REF)"
        fi

        # Clone repository (shallow clone for speed)
        git clone --depth 1 "$REPO_URL" /tmp/ore-build
        cd /tmp/ore-build
        # Fetch the specific ref if shallow clone doesn't have it
        if ! git checkout "$REF" 2>/dev/null; then
          git fetch --depth 1 origin "$REF"
          if ! git checkout FETCH_HEAD; then
            echo "::error::Failed to checkout ore git ref: $REF from $REPO_URL"
            exit 1
          fi
        fi

        # If gfgo-git-ref is set, checkout gemfile-go and create go.work
        if [[ -n "$GFGO_GIT_REF" ]]; then
          echo "Building with gemfile-go from source (git ref: $GFGO_GIT_REF)..."
          GFGO_START_TIME=$(date +%s)
        
          # Parse gemfile-go fork syntax
          if [[ "$GFGO_GIT_REF" == *":"* ]]; then
            GFGO_FORK_OWNER="${GFGO_GIT_REF%%:*}"
            GFGO_REF="${GFGO_GIT_REF#*:}"
            GFGO_REPO_URL="https://github.com/${GFGO_FORK_OWNER}/gemfile-go.git"
            echo "Using fork: $GFGO_FORK_OWNER/gemfile-go (ref: $GFGO_REF)"
          else
            GFGO_REPO_URL="https://github.com/contriboss/gemfile-go.git"
            GFGO_REF="$GFGO_GIT_REF"
            echo "Using upstream: contriboss/gemfile-go (ref: $GFGO_REF)"
          fi

          # Clone gemfile-go repository
          git clone --depth 1 "$GFGO_REPO_URL" /tmp/gemfile-go-build
          cd /tmp/gemfile-go-build
          # Fetch the specific ref if shallow clone doesn't have it
          if ! git checkout "$GFGO_REF" 2>/dev/null; then
            git fetch --depth 1 origin "$GFGO_REF"
            if ! git checkout FETCH_HEAD; then
              echo "::error::Failed to checkout gemfile-go git ref: $GFGO_REF from $GFGO_REPO_URL"
              exit 1
            fi
          fi

          # Create go.work in ore-build directory
          cd /tmp/ore-build
          echo "Creating go.work workspace..."
          go work init .
          go work use /tmp/gemfile-go-build
          echo "go.work created successfully"
          cat go.work
        
          GFGO_END_TIME=$(date +%s)
          GFGO_ELAPSED=$((GFGO_END_TIME - GFGO_START_TIME))
          echo "gfgo-build-time=$GFGO_ELAPSED" >> $GITHUB_OUTPUT
          echo "gemfile-go setup completed in ${GFGO_ELAPSED}s"
        fi

        # Build ore using Go (will use go.work if it exists)
        cd /tmp/ore-build
        go build -o ore ./cmd/ore

        # Install to ~/.local/bin
        mkdir -p ~/.local/bin
        cp ore ~/.local/bin/ore
        chmod +x ~/.local/bin/ore

        ORE_END_TIME=$(date +%s)
        ORE_ELAPSED=$((ORE_END_TIME - ORE_START_TIME))
        echo "build-time=$ORE_ELAPSED" >> $GITHUB_OUTPUT
        
        echo "Built and installed ore from $GIT_REF in ${ORE_ELAPSED}s"
        if [[ -n "$GFGO_GIT_REF" ]]; then
          echo "  with gemfile-go from $GFGO_GIT_REF"
        fi
        ~/.local/bin/ore --version

        # Cleanup build directories
        rm -rf /tmp/ore-build
        if [[ -n "$GFGO_GIT_REF" ]]; then
          rm -rf /tmp/gemfile-go-build
        fi

    - name: Install ore from release
      if: steps.check-support.outputs.use-fallback != 'true' && steps.should-install-ore.outputs.install-ore == 'true' && steps.cache-ore.outputs.cache-hit != 'true' && steps.ore-version.outputs.build-from-source == 'false'
      shell: bash
      run: |
        VERSION="${{ steps.ore-version.outputs.version }}"
        echo "Installing ore $VERSION..."
        curl -fsSL https://raw.githubusercontent.com/contriboss/ore-light/master/scripts/install.sh | bash -s -- --version "$VERSION"
        echo "Installed ore $VERSION"

    - name: Generate gem cache key
      if: steps.check-support.outputs.use-fallback != 'true' && steps.should-install-ore.outputs.install-ore == 'true'
      id: gem-cache-key
      shell: bash
      working-directory: ${{ inputs.working-directory }}
      run: |
        # Determine which Gemfile and lockfile to use based on BUNDLE_GEMFILE
        if [ -n "$BUNDLE_GEMFILE" ]; then
          GEMFILE="$BUNDLE_GEMFILE"
          LOCKFILE="${BUNDLE_GEMFILE}.lock"
        else
          GEMFILE="Gemfile"
          LOCKFILE="Gemfile.lock"
        fi
        
        if [ -f "$LOCKFILE" ]; then
          # Lockfile exists - use its hash for cache key
          CACHE_HASH=$(sha256sum "$LOCKFILE" | awk '{print $1}' | cut -c1-12)
          echo "Using lockfile: $LOCKFILE (hash: $CACHE_HASH)"
        elif [ -f "$GEMFILE" ]; then
          # No lockfile yet - use Gemfile hash to ensure unique cache per Gemfile
          CACHE_HASH=$(sha256sum "$GEMFILE" | awk '{print $1}' | cut -c1-12)
          echo "No lockfile found, using Gemfile: $GEMFILE (hash: $CACHE_HASH)"
        else
          # Neither exists - use generic identifier
          CACHE_HASH="no-gemfile"
          echo "No Gemfile or lockfile found"
        fi

        # Use full Ruby version to prevent ABI mismatch with native extensions
        FULL_RUBY="${{ steps.setup.outputs.ruby-full-version }}"
        CACHE_KEY="setup-ruby-flash-gems-${{ inputs.cache-version }}-${{ steps.platform.outputs.platform }}-ruby-${FULL_RUBY}-${CACHE_HASH}"
        echo "key=$CACHE_KEY" >> $GITHUB_OUTPUT

        # Only restore from caches with the same full Ruby version to prevent ABI mismatches
        echo "restore-keys=setup-ruby-flash-gems-${{ inputs.cache-version }}-${{ steps.platform.outputs.platform }}-ruby-${FULL_RUBY}-" >> $GITHUB_OUTPUT

    - name: Cache gems
      if: steps.check-support.outputs.use-fallback != 'true' && steps.should-install-ore.outputs.install-ore == 'true'
      id: cache-gems
      uses: actions/cache@v4
      with:
        path: |
          ${{ steps.setup.outputs.ruby-prefix }}/lib/ruby/gems
          ~/.cache/ore/gems
        key: ${{ steps.gem-cache-key.outputs.key }}
        restore-keys: ${{ steps.gem-cache-key.outputs.restore-keys }}

    - name: Install gems with ore
      if: steps.check-support.outputs.use-fallback != 'true' && steps.should-install-ore.outputs.install-ore == 'true' && (inputs.ore-install == 'true' || inputs.bundler-cache == 'true')
      id: install-gems
      shell: bash
      working-directory: ${{ inputs.working-directory }}
      run: |
        # Environment variables (GEM_HOME, GEM_PATH, etc.) are already set via GITHUB_ENV
        # from the "Configure Ruby environment" step
        
        # Verify we're using the right Ruby
        echo "Using Ruby: $(which ruby)"
        echo "Ruby version: $(ruby --version)"
        echo "GEM_HOME: $GEM_HOME"
        
        # Debug: Check what gems are already in GEM_HOME
        echo "==> Gems in $GEM_HOME before ore install:"
        if [ -d "$GEM_HOME/gems" ]; then
          ls -1 "$GEM_HOME/gems" | head -20
        else
          echo "  (gems directory doesn't exist yet)"
        fi

        # Debug: Check specific gems that might be needed by a lockfile
        echo "==> Checking specific gems BEFORE ore install:"
        for gem in kettle-dev-1.2.4 kettle-test-1.0.7 kettle-soup-cover-1.1.1 version_gem-1.1.9; do
          echo "  $gem:"
          echo "    gem dir: $([ -d "$GEM_HOME/gems/$gem" ] && echo 'EXISTS' || echo 'MISSING')"
          echo "    gemspec: $([ -f "$GEM_HOME/specifications/$gem.gemspec" ] && echo 'EXISTS' || echo 'MISSING')"
        done

        # Configure .gemrc to skip documentation if requested
        # This affects all gem installations including those done by Bundler/ore
        # Only create .gemrc if it doesn't already exist (don't override user's settings)
        if [ "${{ inputs.no-document }}" = "true" ]; then
          if [ ! -f ~/.gemrc ]; then
            echo "gem: --no-document" > ~/.gemrc
            echo "Created .gemrc to skip documentation"
          else
            echo "Skipping .gemrc creation - file already exists (user settings preserved)"
          fi
        fi

        # Build ore install command
        INSTALL_CMD="ore install"
        if [ "${{ inputs.skip-extensions }}" = "true" ]; then
          INSTALL_CMD="$INSTALL_CMD --skip-extensions"
        fi
        if [ -n "${{ inputs.without-groups }}" ]; then
          INSTALL_CMD="$INSTALL_CMD --without ${{ inputs.without-groups }}"
        fi

        echo "Running: $INSTALL_CMD"
        echo "DEBUG: BUNDLE_GEMFILE=$BUNDLE_GEMFILE"
        START_TIME=$(date +%s)
        ORE_DEBUG=1 $INSTALL_CMD
        END_TIME=$(date +%s)
        ELAPSED=$((END_TIME - START_TIME))
        
        # Debug: Show the lockfile that was generated
        if [ -n "$BUNDLE_GEMFILE" ]; then
          LOCKFILE="${BUNDLE_GEMFILE}.lock"
        else
          LOCKFILE="Gemfile.lock"
        fi
        echo "==> Lockfile contents ($LOCKFILE):"
        if [ -f "$LOCKFILE" ]; then
          cat "$LOCKFILE"
        else
          echo "  (lockfile not found!)"
        fi
        
        # Debug: Check what gems are in GEM_HOME after ore install
        echo "==> Gems in $GEM_HOME/gems after ore install:"
        if [ -d "$GEM_HOME/gems" ]; then
          ls -1 "$GEM_HOME/gems" | head -20
        else
          echo "  (gems directory doesn't exist!)"
        fi

        echo "==> Gemspecs in $GEM_HOME/specifications after ore install:"
        if [ -d "$GEM_HOME/specifications" ]; then
          ls -1 "$GEM_HOME/specifications" | head -20
          echo "  Total gemspecs: $(ls -1 "$GEM_HOME/specifications" | wc -l)"
        else
          echo "  (specifications directory doesn't exist!)"
        fi

        # Debug: Check specific gems AFTER ore install
        echo "==> Checking specific gems AFTER ore install:"
        for gem in kettle-dev-1.2.4 kettle-test-1.0.7 kettle-soup-cover-1.1.1 version_gem-1.1.9; do
          echo "  $gem:"
          echo "    gem dir: $([ -d "$GEM_HOME/gems/$gem" ] && echo 'EXISTS' || echo 'MISSING')"
          echo "    gemspec: $([ -f "$GEM_HOME/specifications/$gem.gemspec" ] && echo 'EXISTS' || echo 'MISSING')"
        done

        # Run ore info --debug on a failing gem to get detailed diagnostics
        echo "==> Running ore info --debug for detailed diagnostics..."
        ore info --debug --version 1.2.4 kettle-dev || true

        # Verify Bundler can find all gems that ore installed
        # If this fails, ore is broken - do NOT fall back to bundle install
        echo "==> Running bundle check to verify ore installation..."
        if ! bundle check; then
          echo ""
          echo "ERROR: bundle check failed after ore install!"
          echo "This means ore did not install gems correctly."
          echo "ore must install gems such that 'bundle exec' works without 'bundle install'."
          echo ""
          echo "==> Debug: Checking for specific gems from lockfile..."
          # Show first few gems from lockfile and check if their gemspecs exist
          if [ -f "$LOCKFILE" ]; then
            echo "First 5 gems from lockfile:"
            grep -E "^    [a-z]" "$LOCKFILE" | head -5 | while read -r line; do
              gem_name=$(echo "$line" | sed 's/^ *//' | cut -d' ' -f1)
              gem_version=$(echo "$line" | sed 's/^ *//' | cut -d'(' -f2 | cut -d')' -f1)
              gemspec_file="$GEM_HOME/specifications/${gem_name}-${gem_version}.gemspec"
              gem_dir="$GEM_HOME/gems/${gem_name}-${gem_version}"
              echo "  $gem_name-$gem_version:"
              echo "    gemspec exists: $([ -f "$gemspec_file" ] && echo 'YES' || echo 'NO') ($gemspec_file)"
              echo "    gem dir exists: $([ -d "$gem_dir" ] && echo 'YES' || echo 'NO') ($gem_dir)"
            done
          fi
          exit 1
        fi

        echo "ore-version=${{ steps.ore-version.outputs.version }}" >> $GITHUB_OUTPUT
        echo "cache-hit=${{ steps.cache-gems.outputs.cache-hit }}" >> $GITHUB_OUTPUT

        # Get RubyGems and Bundler versions for summary
        RUBYGEMS_VERSION="${{ steps.configure-rubygems.outputs.version }}"
        if [ -z "$RUBYGEMS_VERSION" ]; then
          RUBYGEMS_VERSION="${{ steps.setup.outputs.gem-version }}"
        fi
        BUNDLER_VERSION="${{ steps.install-bundler.outputs.version }}"
        if [ -z "$BUNDLER_VERSION" ]; then
          BUNDLER_VERSION=$(bundle --version 2>/dev/null | awk '{print $NF}' || echo "default")
        fi

        # Summary
        echo "### setup-ruby-flash Summary âš¡" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "| Component | Value |" >> $GITHUB_STEP_SUMMARY
        echo "|-----------|-------|" >> $GITHUB_STEP_SUMMARY
        echo "| Ruby Version | ${{ steps.detect-ruby.outputs.version }} |" >> $GITHUB_STEP_SUMMARY
        echo "| RubyGems Version | $RUBYGEMS_VERSION |" >> $GITHUB_STEP_SUMMARY
        echo "| Bundler Version | $BUNDLER_VERSION |" >> $GITHUB_STEP_SUMMARY
        echo "| rv Version | ${{ steps.rv-version.outputs.version }} |" >> $GITHUB_STEP_SUMMARY
        echo "| ore Version | ${{ steps.ore-version.outputs.version }} |" >> $GITHUB_STEP_SUMMARY
        echo "| Platform | ${{ steps.platform.outputs.platform }} |" >> $GITHUB_STEP_SUMMARY
        echo "| Gem Cache Hit | ${{ steps.cache-gems.outputs.cache-hit }} |" >> $GITHUB_STEP_SUMMARY
        
        # Add timing information
        if [ -n "${{ steps.build-rv.outputs.build-time }}" ]; then
          echo "| rv Build Time | ${{ steps.build-rv.outputs.build-time }}s |" >> $GITHUB_STEP_SUMMARY
        fi
        if [ -n "${{ steps.install-rv.outputs.install-time }}" ]; then
          echo "| rv Install Time | ${{ steps.install-rv.outputs.install-time }}s |" >> $GITHUB_STEP_SUMMARY
        fi
        if [ -n "${{ steps.install-ruby.outputs.install-time }}" ]; then
          echo "| Ruby Install Time | ${{ steps.install-ruby.outputs.install-time }}s |" >> $GITHUB_STEP_SUMMARY
        fi
        if [ -n "${{ steps.build-ore.outputs.gfgo-build-time }}" ]; then
          echo "| gemfile-go Build Time | ${{ steps.build-ore.outputs.gfgo-build-time }}s |" >> $GITHUB_STEP_SUMMARY
        fi
        if [ -n "${{ steps.build-ore.outputs.build-time }}" ]; then
          echo "| ore Build Time | ${{ steps.build-ore.outputs.build-time }}s |" >> $GITHUB_STEP_SUMMARY
        fi
        echo "| Gem Install Time | ${ELAPSED}s |" >> $GITHUB_STEP_SUMMARY
